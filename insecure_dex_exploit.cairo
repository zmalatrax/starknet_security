%lang starknet

@contract_interface
namespace IInsecureDexLP {
    func addLiquidity(amount0 : Uint256,amount1 : Uint256) -> (liquidity : Uint256){}
    func removeLiquidity(amount : Uint256) -> (amount0 : Uint256,amount1 : Uint256){}
}

from starkware.cairo.common.cairo_builtins import HashBuiltin
from starkware.cairo.common.uint256 import Uint256
from starkware.cairo.common.alloc import alloc

@storage_var
func dex() -> (value: felt) {}

@storage_var
func token_20() -> (value: felt) {}

@storage_var
func token_223() -> (value: felt) {}

@constructor
func constructor{ syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr }(dex_address : felt, token_20_address : felt, token_223_address: felt) {
    dex.write(dex_address);
    token_20.write(token_20_address);
    token_223.write(token_223_address);
    return ();
}

@external
func add_liquidity{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(amount0 : Uint256, amount1 : Uint256) {
    let (dex_address) = dex.read();
    IInsecureDexLP.addLiquidity(contract_address=dex_address, amount0=amount0, amount1=amount1);
}

@external
func remove_liquidity{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(amount : Uint256) {
    let (dex_address) = dex.read();
    IInsecureDexLP.removeLiquidity(contract_address=dex_address, amount0=amount, amount1=amount);
}


@external

func tokenReceived{syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr}(address : felt, amount : Uint256, calldata_len : felt, calldata : felt*) {
    while amount != 0 {
        return remove_liquidity(amount, amount);
    };
    // Don't know how loops are handled in cairo 0
    // loop {
    //     if amount != 0 {
    //         return remove_liquidity(amount, amount);
    //     } else {
    //         return ();
    //     }
    // }
    return();
}